# åŸºç¡€ç¯‡

## 01 å †ã€æ ˆã€RAIIï¼šC++é‡Œè¯¥å¦‚ä½•ç®¡ç†èµ„æº

### å †

å†…å­˜æ³„æ¼æ¡ˆä¾‹ï¼š

```c
void foo()
{
  bar* ptr = new bar();
  â€¦
  delete ptr;
}
```

ä¸Šè¿°ä»£ç å­˜åœ¨ä¸¤ä¸ªé—®é¢˜ï¼š

1. ä¸­é—´çœç•¥çš„ä»£ç éƒ¨åˆ†ä¹Ÿè®¸ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œå¯¼è‡´æœ€åçš„ delete ptr å¾—ä¸åˆ°æ‰§è¡Œã€‚
2. æ›´é‡è¦çš„ï¼Œè¿™ä¸ªä»£ç ä¸ç¬¦åˆ C++ çš„æƒ¯ç”¨æ³•ã€‚åœ¨ C++ é‡Œï¼Œè¿™ç§æƒ…å†µä¸‹æœ‰ 99% çš„å¯èƒ½æ€§ä¸åº”è¯¥ä½¿ç”¨å †å†…å­˜åˆ†é…ï¼Œè€Œåº”ä½¿ç”¨æ ˆå†…å­˜åˆ†é…ã€‚è¿™æ ·å†™ä»£ç çš„ï¼Œä¼°è®¡å¯èƒ½æ˜¯ä» Java è½¬è¿‡æ¥çš„ğŸ¤­â€”â€”ä½†æˆ‘çœŸè§è¿‡è¿™æ ·çš„ä»£ç ã€‚

è€Œæ›´åˆç†çš„æƒ…å†µå¦‚ä¸‹ï¼š

```c
bar* make_bar(â€¦)
{
  bar* ptr = nullptr;
  try {
    ptr = new bar();
    â€¦
  }
  catch (...) {
    delete ptr;
    throw;
  }
  return ptr;
}

void foo()
{
  â€¦
  bar* ptr = make_bar(â€¦)
  â€¦
  delete ptr;
}
```

### RAII

C++ æ”¯æŒå°†å¯¹è±¡å­˜å‚¨åœ¨æ ˆä¸Šé¢ã€‚ä½†æ˜¯ï¼Œåœ¨å¾ˆå¤šæƒ…å†µä¸‹ï¼Œå¯¹è±¡ä¸èƒ½ï¼Œæˆ–ä¸åº”è¯¥ï¼Œå­˜å‚¨åœ¨**æ ˆ**ä¸Šã€‚æ¯”å¦‚ï¼š

- å¯¹è±¡å¾ˆå¤§
- å¯¹è±¡çš„å¤§å°åœ¨ç¼–è¯‘æ—¶ä¸èƒ½ç¡®å®š
- å¯¹è±¡æ—¶å‡½æ•°çš„è¿”å›å€¼ï¼Œä½†æ˜¯ç”±äºç‰¹æ®Šçš„åŸå› ï¼Œä¸åº”ä½¿ç”¨å¯¹è±¡çš„å€¼è¿”å›



å¸¸è§æƒ…å†µä¹‹ä¸€ï¼Œåœ¨å·¥å‚æ–¹æ³•æˆ–å…¶ä»–é¢å‘å¯¹è±¡ç¼–ç¨‹çš„æƒ…å†µä¸‹ï¼Œè¿”å›å€¼ç±»å‹æ˜¯åŸºç±»ï¼ˆçš„æŒ‡é’ˆæˆ–å¼•ç”¨ï¼‰ã€‚ä¸‹é¢çš„ä¾‹å­ï¼Œæ˜¯å¯¹å·¥å‚æ–¹æ³•çš„ç®€å•æ¼”ç¤ºï¼š

```c
enum class shape_type {
  circle,
  triangle,
  rectangle,
  â€¦
};

class shape { â€¦ };
class circle : public shape { â€¦ };
class triangle : public shape { â€¦ };
class rectangle : public shape { â€¦ };

shape* create_shape(shape_type type)
{
  â€¦
  switch (type) {
  case shape_type::circle:
    return new circle(â€¦);
  case shape_type::triangle:
    return new triangle(â€¦);
  case shape_type::rectangle:
    return new rectangle(â€¦);
  â€¦
  }
}
```

???  è¿™ä¸ª create_shape æ–¹æ³•ä¼šè¿”å›ä¸€ä¸ª shape å¯¹è±¡ï¼Œå¯¹è±¡çš„å®é™…ç±»å‹æ˜¯æŸä¸ª shape çš„å­ç±»ï¼Œåœ†å•Šï¼Œä¸‰è§’å½¢å•Šï¼ŒçŸ©å½¢å•Šï¼Œç­‰ç­‰ã€‚è¿™ç§æƒ…å†µä¸‹ï¼Œå‡½æ•°çš„è¿”å›å€¼åªèƒ½æ˜¯æŒ‡é’ˆæˆ–å…¶å˜ä½“å½¢å¼ã€‚å¦‚æœè¿”å›ç±»å‹æ˜¯ shapeï¼Œå®é™…å´è¿”å›ä¸€ä¸ª circleï¼Œç¼–è¯‘å™¨ä¸ä¼šæŠ¥é”™ï¼Œä½†ç»“æœå¤šåŠæ˜¯é”™çš„ã€‚è¿™ç§ç°è±¡å«å¯¹è±¡åˆ‡ç‰‡ï¼ˆobject slicingï¼‰ï¼Œæ˜¯ C++ ç‰¹æœ‰çš„ä¸€ç§ç¼–ç é”™è¯¯ã€‚è¿™ç§é”™è¯¯ä¸æ˜¯è¯­æ³•é”™è¯¯ï¼Œè€Œæ˜¯ä¸€ä¸ªå¯¹è±¡å¤åˆ¶ç›¸å…³çš„è¯­ä¹‰é”™è¯¯ï¼Œä¹Ÿç®—æ˜¯ C++ çš„ä¸€ä¸ªé™·é˜±äº†ï¼Œå¤§å®¶éœ€è¦å°å¿ƒè¿™ä¸ªé—®é¢˜ã€‚

é‚£ä¹ˆï¼Œæˆ‘ä»¬æ€æ ·æ‰èƒ½ç¡®ä¿ï¼Œåœ¨ä½¿ç”¨ create_shape çš„è¿”å›å€¼æ—¶ä¸ä¼šå‘ç”Ÿå†…å­˜æ³„æ¼å‘¢ï¼Ÿ

ç­”æ¡ˆå°±åœ¨ææ„å‡½æ•°å’Œå®ƒçš„æ ˆå±•å¼€è¡Œä¸ºä¸Šã€‚æˆ‘ä»¬åªéœ€è¦æŠŠè¿™ä¸ªè¿”å›å€¼æ”¾åˆ°ä¸€ä¸ªæœ¬åœ°å˜é‡é‡Œï¼Œå¹¶ç¡®ä¿å…¶ææ„å‡½æ•°ä¼šåˆ é™¤è¯¥å¯¹è±¡å³å¯ã€‚ä¸€ä¸ªç®€å•çš„å®ç°å¦‚ä¸‹æ‰€ç¤ºï¼š

```c++
enum class shape_type {
  circle,
  triangle,
  rectangle,
  â€¦
};

class shape { â€¦ };
class circle : public shape { â€¦ };
class triangle : public shape { â€¦ };
class rectangle : public shape { â€¦ };


class shape_wrapper {
public:
  explicit shape_wrapper(shape* ptr = nullptr): ptr_(ptr) {}
  
  ~shape_wrapper()
  {
    delete ptr_;
  }
  
  shape* get() const { return ptr_; }
  
private:
  shape* ptr_;
};

void foo()
{
  â€¦
  shape_wrapper ptr_wrapper(
    create_shape(â€¦));
  â€¦
}
```

å¦‚æœä½ å¥½å¥‡ delete ç©ºæŒ‡é’ˆä¼šå‘ç”Ÿä»€ä¹ˆçš„è¯ï¼Œé‚£ç­”æ¡ˆæ˜¯ï¼Œè¿™æ˜¯ä¸€ä¸ªåˆæ³•çš„ç©ºæ“ä½œã€‚

```c
if (ptr != nullptr) {
  ptr->~shape();
  operator delete(ptr);
}
```

å›åˆ° shape_wrapper å’Œå®ƒçš„ææ„è¡Œä¸ºã€‚åœ¨ææ„å‡½æ•°é‡Œåšå¿…è¦çš„æ¸…ç†å·¥ä½œï¼Œè¿™å°±æ˜¯ RAII çš„åŸºæœ¬ç”¨æ³•ã€‚è¿™ç§æ¸…ç†å¹¶ä¸é™äºé‡Šæ”¾å†…å­˜ï¼Œä¹Ÿå¯ä»¥æ˜¯ï¼š

- å…³é—­æ–‡ä»¶ï¼ˆfstream çš„ææ„å°±ä¼šè¿™ä¹ˆåšï¼‰
- é‡Šæ”¾åŒæ­¥é”
- é‡Šæ”¾å…¶ä»–é‡è¦çš„ç³»ç»Ÿèµ„æº

## 02 è‡ªå·±åŠ¨æ‰‹ï¼Œå®ç°C++çš„æ™ºèƒ½æŒ‡é’ˆ

### å›é¡¾

æˆ‘ä»¬ä¸Šä¸€è®²ç»™å‡ºäº†ä¸‹é¢è¿™ä¸ªç±»ï¼š

```c++
class shape_wrapper {
public:
  explicit shape_wrapper(shape* ptr = nullptr): ptr_(ptr) {}
    
  ~shape_wrapper()
  {
    delete ptr_;
  }
  shape* get() const { return ptr_; }

private:
  shape* ptr_;
};
```

*explicitï¼šæŒ‡å®šæ„é€ å‡½æ•°æˆ–è½¬æ¢å‡½æ•° (C++11 èµ·) æˆ–æ¨å¯¼æŒ‡å— (C++17 èµ·) æ˜¯æ˜¾å¼çš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒä¸èƒ½ç”¨äºéšå¼è½¬æ¢å’Œå¤åˆ¶åˆå§‹åŒ–ã€‚*

è¿™ä¸ªç±»å¯ä»¥å®Œæˆæ™ºèƒ½æŒ‡é’ˆçš„æœ€åŸºæœ¬çš„åŠŸèƒ½ï¼šå¯¹è¶…å‡ºä½œç”¨åŸŸçš„å¯¹è±¡è¿›è¡Œé‡Šæ”¾ã€‚**ä½†å®ƒç¼ºäº†ç‚¹ä¸œè¥¿ï¼š**

1. è¿™ä¸ªç±»åªé€‚ç”¨äº shape ç±»
2. è¯¥ç±»å¯¹è±¡çš„è¡Œä¸ºä¸å¤ŸåƒæŒ‡é’ˆ
3. æ‹·è´è¯¥ç±»å¯¹è±¡ä¼šå¼•å‘ç¨‹åºè¡Œä¸ºå¼‚å¸¸

ä¸‹é¢æˆ‘ä»¬æ¥é€ä¸€çœ‹ä¸€ä¸‹æ€ä¹ˆå¼¥è¡¥è¿™äº›é—®é¢˜ã€‚

### æ¨¡æ¿åŒ–å’Œæ˜“ç”¨æ€§

è¦è®©è¿™ä¸ªç±»èƒ½å¤ŸåŒ…è£…ä»»æ„ç±»å‹çš„æŒ‡é’ˆï¼Œæˆ‘ä»¬éœ€è¦æŠŠå®ƒå˜æˆä¸€ä¸ªç±»æ¨¡æ¿ã€‚è¿™å®é™…ä¸Šç›¸å½“å®¹æ˜“ï¼š

```c++
template <typename T>
class smart_ptr {
public:
  explicit smart_ptr(T* ptr = nullptr) : ptr_(ptr) {}
  ~smart_ptr()
  {
    delete ptr_;
  }
  T* get() const { return ptr_; }
    
private:
  T* ptr_;
};
```

*ç§»åŠ¨æ„é€ å‡½æ•°ï¼š*

*=deleteï¼ŒC++11ä¸­ï¼Œå½“æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªç±»çš„æˆå‘˜å‡½æ•°æ—¶ï¼Œå¦‚æœåé¢ä½¿ç”¨"=delete"å»ä¿®é¥°ï¼Œé‚£ä¹ˆå°±è¡¨ç¤ºè¿™ä¸ªå‡½æ•°è¢«å®šä¹‰ä¸ºdeletedï¼Œä¹Ÿå°±æ„å‘³ç€è¿™ä¸ªæˆå‘˜å‡½æ•°ä¸èƒ½å†è¢«è°ƒç”¨ï¼Œå¦åˆ™å°±ä¼šå‡ºé”™ã€‚*

#### å¼•ç”¨è®¡æ•°

unique_ptr å’Œ shared_ptr çš„ä¸»è¦åŒºåˆ«å¦‚ä¸‹ï¼š

![image-20220313093010188](C:\Users\11575\AppData\Roaming\Typora\typora-user-images\image-20220313093010188.png)

ç°åœ¨æˆ‘ä»¬å¯ä»¥å®ç°æˆ‘ä»¬çš„å¼•ç”¨è®¡æ•°æ™ºèƒ½æŒ‡é’ˆäº†ã€‚é¦–å…ˆæ˜¯æ„é€ å‡½æ•°ã€ææ„å‡½æ•°å’Œç§æœ‰æˆå‘˜å˜é‡ï¼š

```c++
template <typename T>
class smart_ptr {
public:
  explicit smart_ptr(T* ptr = nullptr)
    : ptr_(ptr)
  {
    if (ptr) {
      shared_count_ =
        new shared_count();
    }
  }
  ~smart_ptr()
  {
    if (ptr_ &&
      !shared_count_
         ->reduce_count()) {
      delete ptr_;
      delete shared_count_;
    }
  }

private:
  T* ptr_;
  shared_count* shared_count_;
};
```



ä¸‹é¢æ˜¯ä¸€ä¸ªå®Œæ•´çš„ smart_ptr ä»£ç ï¼š

```c++
#include <utility>  // std::swap

class shared_count {
public:
  shared_count() noexcept
    : count_(1) {}
  void add_count() noexcept
  {
    ++count_;
  }
  long reduce_count() noexcept
  {
    return --count_;
  }
  long get_count() const noexcept
  {
    return count_;
  }

private:
  long count_;
};

template <typename T>
class smart_ptr {
public:
  template <typename U>
  friend class smart_ptr;

  explicit smart_ptr(T* ptr = nullptr)
    : ptr_(ptr)
  {
    if (ptr) {
      shared_count_ =
        new shared_count();
    }
  }
  ~smart_ptr()
  {
    if (ptr_ &&
      !shared_count_
         ->reduce_count()) {
      delete ptr_;
      delete shared_count_;
    }
  }

  smart_ptr(const smart_ptr& other)
  {
    ptr_ = other.ptr_;
    if (ptr_) {
      other.shared_count_
        ->add_count();
      shared_count_ =
        other.shared_count_;
    }
  }
  template <typename U>
  smart_ptr(const smart_ptr<U>& other) noexcept
  {
    ptr_ = other.ptr_;
    if (ptr_) {
      other.shared_count_->add_count();
      shared_count_ = other.shared_count_;
    }
  }
  template <typename U>
  smart_ptr(smart_ptr<U>&& other) noexcept
  {
    ptr_ = other.ptr_;
    if (ptr_) {
      shared_count_ =
        other.shared_count_;
      other.ptr_ = nullptr;
    }
  }
  template <typename U>
  smart_ptr(const smart_ptr<U>& other,
            T* ptr) noexcept
  {
    ptr_ = ptr;
    if (ptr_) {
      other.shared_count_
        ->add_count();
      shared_count_ =
        other.shared_count_;
    }
  }
  smart_ptr&
  operator=(smart_ptr rhs) noexcept
  {
    rhs.swap(*this);
    return *this;
  }

  T* get() const noexcept
  {
    return ptr_;
  }
  long use_count() const noexcept
  {
    if (ptr_) {
      return shared_count_
        ->get_count();
    } else {
      return 0;
    }
  }
  void swap(smart_ptr& rhs) noexcept
  {
    using std::swap;
    swap(ptr_, rhs.ptr_);
    swap(shared_count_,
         rhs.shared_count_);
  }

  T& operator*() const noexcept
  {
    return *ptr_;
  }
  T* operator->() const noexcept
  {
    return ptr_;
  }
  operator bool() const noexcept
  {
    return ptr_;
  }

private:
  T* ptr_;
  shared_count* shared_count_;
};

template <typename T>
void swap(smart_ptr<T>& lhs,
          smart_ptr<T>& rhs) noexcept
{
  lhs.swap(rhs);
}

template <typename T, typename U>
smart_ptr<T> static_pointer_cast(
  const smart_ptr<U>& other) noexcept
{
  T* ptr = static_cast<T*>(other.get());
  return smart_ptr<T>(other, ptr);
}

template <typename T, typename U>
smart_ptr<T> reinterpret_pointer_cast(
  const smart_ptr<U>& other) noexcept
{
  T* ptr = reinterpret_cast<T*>(other.get());
  return smart_ptr<T>(other, ptr);
}

template <typename T, typename U>
smart_ptr<T> const_pointer_cast(
  const smart_ptr<U>& other) noexcept
{
  T* ptr = const_cast<T*>(other.get());
  return smart_ptr<T>(other, ptr);
}

template <typename T, typename U>
smart_ptr<T> dynamic_pointer_cast(
  const smart_ptr<U>& other) noexcept
{
  T* ptr = dynamic_cast<T*>(other.get());
  return smart_ptr<T>(other, ptr);
}
```



# 03 | å³å€¼å’Œç§»åŠ¨ç©¶ç«Ÿè§£å†³äº†ä»€ä¹ˆé—®é¢˜ï¼Ÿ



























































