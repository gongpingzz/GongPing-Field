# 第一部分  DPDK基础篇

# 1  认识DPDK

## 1.7  实例

1. helloworld，启动基础运行环境
2. skeleton，最精简得单核报文收发骨架
3. l3fwd，三层转发是DPDK用于发布性能测试指标的主要应用

### 1.7.1  HelloWorld


# 第三章 并行计算
## 3.1 多核性能和可扩展性
> *Amdahl定律*告诉我们，假设一个任务的工作量不变，多核并行计算理论时延加速上限取决于那些不能并行处理部分的比例

## 3.1.2 多核处理器
> 超线程（Hyper-Threading）在一个处理器中提供两个逻辑执行线程，逻辑线程共享流水线、执行单元和缓存。
>
> ![image-20220226080346329](C:\Users\11575\AppData\Roaming\Typora\typora-user-images\image-20220226080346329.png)



![image-20220226080429997](C:\Users\11575\AppData\Roaming\Typora\typora-user-images\image-20220226080429997.png)

> 1. 处理器核数
>
> 2. 逻辑处理器核心数
>
> 3. 系统物理处理器封装ID
>
> 4. 系统逻辑处理器ID
>
>    ![image-20220226082121833](C:\Users\11575\AppData\Roaming\Typora\typora-user-images\image-20220226082121833.png)

### 3.1.3 亲和性

> 使用亲和性的三个原则：
>
> 1. 有大量计算要做
> 2. 测试复杂的应用程序
> 3. 运行时间敏感的、决定性的线程

> cgroup是controlgroup的缩写，是Linux内核提供的一种可以限制、记录、隔离进程组所使用的物理资源（如：CPU、内存、I/O等）的机制。

> 理解处理器的体系结构以及微架构的设计，对于调优或者高效的代码设计都会很有帮助。这里推荐读者阅读**64-ia-32架构优化手册**，手册中会从前端优化、执行core优化、访存优化、预取等多个方面讲解各类技巧

#### 3.2.2.1 SIMD简介

> SIMD指令操作的寄存器相对于通用寄存器（general-purpose register, RPRS）更宽，128bit的XMM寄存器或者256bit的YMM寄存器，有2倍甚至4倍于通用寄存器的宽度（在64bit架构上）。所以，用SIMD指令的一个直接好处是最大化地利用一级缓存访存的带宽

# 第四章 同步互斥机制

## 4.1 原子操作

> 对原子操作的简单描述就是：多个线程执行一个操作时，其中任何一个线程要么完全执行完此操作，要么没有执行此操作的任何步骤，那么这个操作就是原子的。原子操作是其他内核同步方法的基石。

> 在x86平台上，总的来说，CPU提供三种独立的原子锁机制：**原子保证操作**、**加LOCK指令前缀**和**缓存一致性协议**。

> CMPXCHG这条指令:处理器会自动地遵循LOCK的语义，可见该指令是一条原子的CAS单指令操作。它可是实现很多无锁数据结构的基础

> 硬件原子操作，软件原子操作

## 4.2 读写锁

> 写自旋锁访问共享资源：
>
> 1. 申请锁
> 2. 获得锁后，读写共享资源
> 3. 释放锁

> 读写自旋锁主要用于比较短小的代码片段，线程等待期间不应该进入睡眠状态，因为睡眠/唤醒操作相当耗时,大大延长了获得锁的等待时间，所以我们要求忙等待

## 4.3 自旋锁

> 何谓自旋锁（spin lock）？它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，“自旋”一词就是因此而得名。

### 4.3.1 自旋锁的缺点

> 自旋锁必须基于CPU的数据总线锁定，它通过读取一个内存单元（spinlock_t）来判断这个自旋锁是否已经被别的CPU锁住。记住上面提及到的：锁定数据总线的指令只能保证一个指令操作期间CPU独占数据总线:
>
> 1. 自旋锁一直占用CPU，它在未获得锁的情况下，一直运行——自旋，所以占用着CPU，如果不能在很短的时间内获得锁，这无疑会使CPU效率降低。
> 2. 在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁，调用有些其他函数（如copy_to_user()、copy_from_user()、kmalloc()等）也可能造成死锁。
>
> 因此我们要慎重使用自旋锁，自旋锁只有在内核可抢占式或SMP的情况下才真正需要，在单CPU且不可抢占式的内核下，自旋锁的操作为空操作。自旋锁适用于锁使用者保持锁时间比较短的情况。

## 4.4 无锁机制

### 4.4.1 linux内核无锁环形缓冲

> 在Linux内核代码中，kfifo就是采用无锁环形缓冲的实现。kfifo采用了并行无锁技术，kfifo实现的单生产/单消费模式的共享队列是不需要加锁同步的。更多的细节可以阅读Linux内核代码中的kififo的头文件（include/linux/kfifo.h）和源文件（kernel/kfifo.c）

> DPDK 怎么实现的无锁队列应付多对多模型？

# 5 报文转发

## 5.3 转发算法

### 5.3.1 精确匹配算法

> 精确匹配算法的主要思想就是利用哈希算法对所要匹配的值进行哈希，从而加快查找速度。决定哈希性能的主要参数是负载参数.
>
> 解决哈希冲突的主要方法：
>
> 1. 分离链表
> 2. 开放地址
>
> DPDK中主要支持CRC32和 Jhash

### 5.3.2 最长前缀匹配算法 LPM

### 5.3.3 ACL

# 第六章 PCIE 与包处理IO

## 6.1 从PCIe事务的角度看包处理

> PCI Express（Peripheral Component Interconnect Express）又称PCIe，它是一种高速串行通信互联标准

### 6.1.2 PCIe 事务传输

> TLP（Transaction Layer Packet，事务传输层数据包）

### 6.1.3 PCIe带宽

> 要查看特定PCIe设备的链路能力和当前速率，可以用Linux工具lspci读取PCIe的配置寄存器（Configuration Space）

## 6.3 网卡DMA描述符环形队列

> DMA（Direct Memory Access，直接存储器访问）是一种高速的数据传输方式，允许在外部设备和存储器之间直接读写数据。

## 6.4 数据包收发——CPU和I/O的协奏

> DMA控制器通过一组描述符环行队列与CPU互操作完成包的收发

> 全景分析包收发过程：
>
> 1）CPU填充缓冲地址到接收侧描述符。
>
> 2）网卡读取接收侧描述符获取缓冲区地址。
>
> 3）网卡将包的内容写到缓冲区地址处。
>
> 4）网卡回写接收侧描述符更新状态（确认包内容已写完）。
>
> 5）CPU读取接收侧描述符以确定包接收完毕。
>
> （其中，1）和5）是CPU读写LLC的访存操作；2）是PCIe downstream方向的操作；而3）和4）是PCIe upstream方向的操作。）
>
> 6）CPU读取包内容做转发判断。
>
> 7）CPU填充更改包内容，做发送准备。
>
> （6）和7）属于转发操作，并不是收发的必要操作，都只是CPU的访存操作，不涉及PCIe。）发送方向：
>
> 8）CPU读发送侧描述符，检查是否有发送完成标志。
>
> 9）CPU将准备发送的缓冲区地址填充到发送侧描述符。
>
> 10）网卡读取发送侧描述符中地址。
>
> 11）网卡根据描述符中地址，读取缓冲区中数据内容。
>
> 12）网卡写发送侧描述符，更新发送已完成标记。

### 6.4.2 优化的考虑

> 1. 减少MMIO访问的频度
> 2. 提高PCIe传输的效率
> 3. 尽量避免Cache Line的部分写

## 6.6 Mbuf与Mempool

### 6.6.1 Mbuf

> 为了高效访问数据，DPDK将内存封装在Mbuf（struct rte_mbuf）结构体内。Mbuf主要用来封装网络帧缓存，也可用来封装通用控制信息缓存（缓存类型需使用CTRL_MBUF_FLAG来指定）
>
> 所有应用都应使用Mbuf结构来传输网络帧。



# 第七章 网卡性能优化

## 7.1 DPDK的轮询模式

> DPDK采用了轮询或者轮询混杂中断的模式来进行收包和发包

### 7.1.1 异步中断模式

> 当有包进入网卡收包队列后，**网卡**会**产生硬件（MSIX/MSI/INTX）中断**，进而**触发CPU中断**，**进入中断服务程序**

> **中断是异步方式**，因此CPU无需阻塞等待，有效利用率较高，特别是在收包吞吐率比较低或者没有包进入收包队列的时候，CPU可以用于其他任务处理。

### 7.1.2 轮询模式

> DPDK纯轮询模式是指收发包完全不使用中断处理的高吞吐率的方式，DPDK所有的收发包有关的中断在**物理端口初始化**的时候都会关闭

### 7.1.3 混合中断轮询模式

> DPDK的混合中断轮询机制是基于**UIO或VFIO**来实现其收包中断通知与处理流程的
>
> UIO: 用户空间IO
>
> VFIO: 是一个可以安全的把设备IO、中断、DMA等暴露到用户空间（usespace），从而在用户空间完成设备驱动的框架。

## 7.2 网卡I/O性能优化

### 7.2.1 Burst 收发包的优点

> DPDK的收发包是一个相对复杂的软件运算过程，
>
> 1. 其中主要包含Mbuf的分配或者释放，
> 2. 以及描述符的解析或者构造，涉及多次数据结构访问，包含读和写。

### 7.2.2 批处理和时延隐藏

> 1）时延（Latency）：处理器核心执行单元完成一条指令（instruction）所需要的时钟周期数。'
>
> 2）吞吐（Throughput）：处理器指令发射端口再次允许接受相同指令所需等待的时钟周期数。

## 7.5 小结

> 本章从**网卡、处理器、内存、PCIe接口**等硬件系统，以及**BIOS、操作系统和DPDK软件编写**角度总结了影响系统性能的元素











