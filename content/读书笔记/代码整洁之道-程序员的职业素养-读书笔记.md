# 第一章  专业主义

## 1.3  首先，不行损害之事

### 1.3.1  不要破坏软件功能

> 什么样的代码有缺陷呢？那些你没有把握的代码都是

> 但是有些代码不是很难测试吗？是的，但之所以很难测试，是因为设计时就没考虑如何测试，唯一的方法就是要设计易于测试的代码最好是先写测试，再写要测试的代码。这一方法叫做**测试驱动开发（TDD）**

### 1.3.2  不要破坏结构

> 如果一直不重构代码，等到最后不得不重构时，你就会发现代码已经“僵化了”

> 下面列出每个专业软件开发人员必须精通的事项：
>
> 1. 设计模式：必须能描述GOF书中的全部24中模式，同时还要有POSA书中的多数模式的实战经验。
> 2. 设计原则。必须了解SOLID原则，而且要深刻理解组件设计原则，
> 3. 方法。必须XP,Scrum,精益，看板，瀑布，结构化分析和结构化设计等。
> 4. 实践，必须掌握测试驱动开发、面向对象设计，结构化编程，持续集成和结对编程
> 5. 工件。必须了解如何使用UML图，DFD图、结构图、Petri网络图、状态迁移图标、流程图和决策表

> 如果你是c语言程序员，就去学学Lisp

> 练习 “kata”

#  第二章 说“不” 

> 能就是能，不能就是不能，不要说试试看

## 2.1  对抗角色

> 对话1：
>
> Mike: "Paula, 你明天之前要完成那个登录页面"
>
> Paula: "噢，喔，要这么快啊？那好吧，我会尽量试试。"
>
> Mike: ""好极了，谢谢"
>
> 
>
> 对话2：
>
> Mike: "Paula, 你明天之前要完成那个登录页面。"
>
> Paula: "噢，抱歉，这么短的时间完成不了"
>
> Mike: "那你觉得什么时候能完成呢?"
>
> Paula: "再过两周怎么样？"
>
> Mike: “（在他的本子上记了几笔）好的，谢谢”
>
> 
>
> 对话3：
>
> Mike: "Paula, 你在明天之前要完成那个登录页面"
>
> Paula: "不，Mike, 这个活要两周才能完成。"
>
> Mike: “两周？架构师估计这只要3天，而你已经花了5天时间。”
>
> Paula: “架构师们错了，Mike。他们是在接到产品销售需求前做的预估，我至少还需要10天才能做完。你没看到我再wiki上的更新吗？”
>
> Mike: "（表情严肃，沮丧得发抖）Paula，这可不行，客户明天就要来看demo了，我必须向他们展示个能用的登录界面。"
>
> Paula: "明天你需要登录界面的哪部分能用?"
>
> Mike: “我要整个登录页面！必需要能登录”
>
> Paula: "Mike, 我可以给你做个能登录的假页面。这个现在已经可以了，但是页面不会检查用户名和密码。如果你把密码忘记了，也还是没有办法发邮件告诉你，页面顶部也还不能像时代广场的大屏幕那样有新闻栏滚动，帮助按钮和浮出说明都还不能用，它没法为你保存cookie以便下次登录，也不会设定任何权限限制。但你确实可以登录。你看这样可以吗？"
>
> Mike: "我可以登录?"
>
> Paula: "是的，可以登录"
>
> Mike: "好极了，Paula, 你可真是个大救星。（送了口气，说了声“太棒了!”, 走开了）"



# 第三章  说“是”

# 第四章  编码

> 出错感知能力

## 4.1  做好准备

###  4.2  焦虑时写下的代码

# 第五章 测试驱动开发

## 5.2 TDD的三项法则

> 1. 在编号失败单元测试之前，不要编写任何产品代码
> 2. 只要有一个单元测试失败了，就不要再写测试代码；无法通过编译也是一种失败情况
> 3. 产品代码恰好能够让当前失败的单元测试成功通过即可，不要多写

## 5.3 TDD的优势

> 确定性
>
> 缺陷注入率
>
> 勇气
>
> 文档
>
> 设计





# 第7章 验收测试

## 7.1 需求的沟通

### 7.1.1 过早精细化

> 观察者效应：或者叫不确定原则，每次你向业务方展示一项功能，他们就会获得比之前更多的信息，这些信息反过来又会影响他们对整个系统的看法。

> **需求是一定会变化的**，追求精确性是徒劳

> 评估中使用”误差棒“

## 7.2 验收测试

> 验收测试实在正式发布之前由用户执行的程序，也有人认为它是QA测试

### 7.2.1 “完成”的定义

> 专业开发人员的“完成“只能有一个定义，完成，就是完成。完成意味着所有代码都写完了，所有测试都通过了，QA和需求方都已经认可了。这才是完成。

### 7.2.2 沟通

> 验收测试的目的是沟通、澄清、精细化。

### 7.2.3 自动化

> 验收测试都应当自动化，为成本考虑

> 自动话验收测试工具： FitNesse  Cucumber  cuke4duke  root_framework  Selenium

### 7.2.5 验收测试什么时候写，由谁来写

> 如果只能由开发人员来写测试，应当确保**写测试的程序员**与**开发所测试功能的程序员**不是同一个人。

### 7.2.7 测试的协商与被动推进

> 测试本身有错误，绝不能被动的接受测试。

# 第8章 测试策略

> 自动化测试金字塔：
>
> ![测试金字塔](images\测试金字塔.png)

> 1. 单元测试：
>    - 单元测试做到接近100%的测试覆盖率，通常而言，需要保持在90%以上
> 2. 组件测试：系统的组件封装了业务规则，对这些组件的测试便是对其中业务规则的验收测试
> 3. 集成测试：主要测试组件装配在一起时能否协调
> 4. 系统测试：时最终的集成测试，测试系统是否正确组装完毕，以及各个部件之间是否能正确交互，应该也包含吞吐率测试和性能测试。
> 5. 人工探索式测试：这些测试的意图实在严重预期行为的时候，探索系统预期之外的行为，为了达到这个目的，需要人类智慧的接入，对系统进行深入研究和探索。

# 第9章 时间管理

> 8小时，只有480分钟，28800秒

> 预留机动时间

## 9.1 会议记录

> 会议的成本时每人每小时200美元

> 关于会议的两条正理：
>
> 1. 会议是必须的
> 2. 会议浪费了大量时间

### 9.1.1 拒绝

> 礼貌拒绝一些会议，为时间负责的只有你

> 领导的重要责任之一，就是帮你从某些会议脱身

### 9.1.2 离席

> 选个合适的机会商量如何离席，并非不专业的做法

### 9.1.4 立会

> 敏捷开发中的武器库包含”立会“，在开会时，所有参会者必须都站着。到场的人依次回答以下3个问题：
>
> 1. 我昨天干了什么？
> 2. 我今天打算干什么？
> 3. 我遇到了什么问题？
>
> 这就是会议的全部内容，每个问题的回答时间不应当超过20秒。

### 9.1.7 争论反对

> 凡是不能在5分钟内解决的问题，都不能靠辩论解决。 因为各方都拿不出有力的证据。

## 9.2 注意力点数

> 编程时需要持续投入精力和注意力的智力活动，注意力时稀缺的资源，它类似魔力点数，如果你用光了自己的注意力点数，必须花一个小时或者更多的时间做不需要注意力的事情，来补充它。

## 9.3 时间拆分与番茄工作法

> 番茄工作法的基本思想很简答：把厨房的计时器（通常它很想番茄）设定到25分钟。倒计时期间不要让任何事情干扰你工作。如果电话响了，接起来礼貌的告诉人家，请在25分钟之后打来。无论什么干扰，都必须等到25分钟后再处理。

> 一天有几个番茄时间段，你可以记录下来，就可以很清楚的知道，每天有多少时间是有效率的，有多少时间是花在杂事上。

## 9.4 要避免的行为

#### 优先级错乱

# 第10章 预估

## 10.1 什么是预估

> 业务方觉得预估是**承诺**，开发方觉得预估是**猜测**

### 10.1.1 承诺

> 如果要求你承诺在某天完成，但是需要每天加班，周末加班，放弃休假，那么最后的决定取决于你；不过，不要违背自己的意愿去勉强。

## 10.2 PERT

> 计划评审技术（PERT Program Evaluation and Review Technique）,你可以根据三个数字预估某项任务，这就是三元分析法：
>
> O：乐观预估
>
> N：标称预估
>
> P：悲观预估
>
> u = (O + 4N + P) / 6   u是任务的期望完成时间

## 10.3 预估任务

1. 德尔菲法
2. 亮手指
3. 规划扑克
4. 关联预估
5. 三元预估

## 10.4 大数预估

> 预估中控制错误的办法之一就是使用大数定律：该定律的意思是：把大任务分成许多小任务。分开预估再加总，结果会比单独评估大任务要精确很多，这样做之所以能提高精确度，是因为小任务的预估错误几乎可以被忽略 ，不会对总的结果产生明显的影响。

# 第11章  压力



# 第12章  协作

为公司目标考虑

结对编程



# 第13章  团队与项目



# 第14章  辅导、学徒期与技艺

### 14.3.1 软件学徒期

> 1. 大师（10年）
> 2. 熟练工（5年）
> 3. 学徒（至少1年）



# 附录  工具





































