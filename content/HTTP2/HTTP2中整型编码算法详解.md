<center><font size = 6>HTTP2之HPACK整型编码算法详解</font></center>

# 1  整型编码算法简介

HTTP2 头部压缩算法 HPACK 中，编码使用两种原始类型，无符号可变长整型和8位字节串。无符号可变长整型主要用于表示头部索引，字符串长度，  我们本文要讨论的就是无符号可变长整型值的编码算法以及解码方式。

# 2  编码

在 HPACK 中，名字索引，头部字段索引，字符串长度使用整型编码表示，编码可以从一个字节的任意未知开始，但是必须以一个字节作为结尾。整型编码分为两部分：

1. prefix : 当前字节未使用的剩余部分
2. an optiolal list of octets : 如果待编码值使用 prefix 不足以编码，也就是代编码值大于 prefix 所表示的最大值，那么需要额外的字节用于编码

我们把 prefix 的位数表示为 N ， 如果整型值小于 2^N - 1， 则只需要使用 N-bit prefix 编码即可。

```
   0   1   2   3   4   5   6   7
 +---+---+---+---+---+---+---+---+
 | ? | ? | ? | Value 			 |
 +---+---+---+-------------------+  使用 prefix 的整型值编码（N = 5）
```

相反，则需要额外的字节进行编码，需要编码的值等于原来的值减去  2^N - 1，额外字节的头部最高有效位用于表示“**连续标志位**”，连续标志位置为 1 ，表示后续还有用于编码整型值的字节，若为 0 ，则表示这是最后一个用于编码整型值的字节。

```
   0   1   2   3   4   5   6   7
 +---+---+---+---+---+---+---+---+
 | ? | ? | ? | 1   1   1   1   1 |
 +---+---+---+-------------------+
 | 1 | Value-(2^N-1) LSB 		 |
 +---+---------------------------+
 ...
 +---+---------------------------+
 | 0 | Value-(2^N-1) MSB         |
 +---+---------------------------+  prefix 之后的编码
```

那么额外的字节如何编码减去（2^N - 1）剩余的整型值呢？假设已经编码完成，这时候你把编码字节顺序反转，然后去掉连续标志位，把得到的值再加上 prefix 编码的值就是所编码的整型值。

编码伪代码如下：

```c
if I < 2^N - 1, encode I on N bits
    else
        encode (2^N - 1) on N bits
        I = I - (2^N - 1)
        while I >= 128
            encode (I % 128 + 128) on 8 bits
            I = I / 128
            encode I on 8 bits
```

# 3  解码

知道了编码方式，解码就很 easy 了。伪代码如下：

```c
decode I from the next N bits
    if I < 2^N - 1, return I
        else
            M = 0
            repeat
            B = next octet
            I = I + (B & 127) * 2^M
            M = M + 7
            while B & 128 == 128
                return I
```

# 4  举例

### 4.1  Example 1:   Encoding 1337 Using a 5-Bit Prefix

1337 大于 31（2^5-1），并使用 5 位前缀表示。5 位前缀使用其最大值（31）填充。

I = 1337 - (2^5 - 1) = 1306。I (1306) 大于等于 128。I % 128 == 26，26 + 128 == 154，

154 用 8 位表示为: 10011010。I 现在是 10，(1306 / 128 == 10)，用 8 位表示为: 00001010。

```
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | X | X | X | 1 | 1 | 1 | 1 | 1 |  Prefix = 31, I = 1306
   | 1 | 0 | 0 | 1 | 1 | 0 | 1 | 0 |  1306>=128, encode(154), I=1306/128
   | 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 |  10<128, encode(10), done
   +---+---+---+---+---+---+---+---+
```

现在我们把字节顺序反转再连接：

```c
1、反转连接：
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 0 | 1 | 1 | 0 | 1 | 0 |   
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  |  							  |	
flag1							flag2
    
2、去掉连续标志位
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| x | 0 | 0 | 0 | 1 | 0 | 1 | 0 | x | 0 | 0 | 1 | 1 | 0 | 1 | 0 |   
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
    
value = 101 0001 1010 + 000111111 = 1306 + 31 = 1337
```

#  总结与思考

之前跟朋友讨论HTTP2 HPACK如何解码，朋友抱怨道其整型编码这部分如何复杂难搞，仔细分析下来，其实并不复杂。

为什么要采用这种编码方式，如果我们从最简单的出发，简单的把每个字节编码的值简单相加，第一个连续标志位保留，那么

1337 = 127 * 10 + 67，开销这么大，肯定不合适，另外这种编码方式也能有效的防止整型溢出。



#  reference

RFC 7541